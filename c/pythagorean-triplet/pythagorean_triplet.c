#include "pythagorean_triplet.h"
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>

static int gcd(int a, int b)
{
    /* Implement Euclid's algorithm */
    if (a == 0 || b == 0)
    {
        return a > b ? a : b;
    }
    return a > b ? gcd(b, a % b) : gcd(a, b % a);
}

static int ipow(int base, int exp)
{
    /* Implement "fast" exponentiation */
    int result = 1;
    while (exp)
    {
        result *= (exp & 1) ? base : 1;
        exp >>= 1;
        base *= base;
    }
    return result;
}

static triplet_t create_triplet(int u, int v, int d)
{
    triplet_t triplet;
    int a = (ipow(u, 2) - ipow(v, 2)) * d, b = 2 * u * v * d;
    triplet.a = a < b ? a : b;
    triplet.b = triplet.a == a ? b : a;
    triplet.c = (ipow(u, 2) + ipow(v, 2)) * d;
    return triplet;
}

triplets_t *triplets_with_sum(int sum)
{
    /* Create and allocate memory for struct */
    triplets_t *triplets = malloc(sizeof(triplets_t));
    if (!triplets)
    {
        return NULL;
    }
    triplets->count = 0;

    /* If `sum` is odd, no Pythagorean triple is possible */
    if (sum % 2 != 0)
    {
        return triplets;
    }

    for (int u = 2, i = 0, u_bound = (int)ceil(sqrt((double)sum / 2));
         u < u_bound; ++u)
    {
        /* Find `u` that divides `sum / 2` */
        if ((sum / 2) % u == 0)
        {
            for (int v = (u % 2) == 0 ? 1 : 2; v < u; v += 2)
            {
                /* Find `v` that satisfies conditions to generate primitive
                 * Pythagorean triple */
                if ((gcd(u, v) == 1) && ((sum / (2 * u)) % (u + v) == 0))
                {
                    /* Reallocate memory to accomodate new triplet */
                    if ((triplets =
                             realloc(triplets,
                                     sizeof(*triplets) + (++i) *
                                     sizeof(triplet_t))))
                    {
                        /* Find `d` that yields scaled or primitive Pythagorean
                         * triplet given primitive generated by `u`, `v` via
                         * Euclid's method */
                        int d = sum / (2 * u * (u + v));
                        triplets->triplets[triplets->count++] = create_triplet(
                            u, v, d);
                    }
                    else
                    {
                        free_triplets(triplets);
                        return NULL;
                    }
                }
            }
        }
    }

    return triplets;
}

void free_triplets(triplets_t *triplets)
{
    free(triplets);
}
